import { create } from 'zustand';
import type { Conversation, Message } from '../types';
import { dummyConversations } from '../data/dummyData';

interface ChatState {
  conversations: Conversation[];
  activeConversationId: string | null;
  autoStore: boolean;
  
  // Actions
  createConversation: (workspaceId: string, modelId: string, title?: string) => string;
  updateConversation: (id: string, updates: Partial<Conversation>) => void;
  deleteConversation: (id: string) => void;
  setActiveConversation: (id: string | null) => void;
  sendMessage: (conversationId: string, content: string, role?: 'user' | 'assistant') => void;
  pinMessage: (messageId: string) => void;
  unpinMessage: (messageId: string) => void;
  deleteMessage: (messageId: string) => void;
  injectMemory: (conversationId: string, memoryId: string) => void;
  removeInjectedMemory: (conversationId: string, memoryId: string) => void;
  setAutoStore: (enabled: boolean) => void;
  
  // Selectors
  getConversationsByWorkspace: (workspaceId: string) => Conversation[];
  getConversationById: (id: string) => Conversation | undefined;
  getActiveConversation: () => Conversation | null;
  getMessageById: (id: string) => Message | undefined;
}

export const useChatStore = create<ChatState>((set, get) => ({
  conversations: dummyConversations,
  activeConversationId: null,
  autoStore: true,

  createConversation: (workspaceId: string, modelId: string, title?: string) => {
    const newConversation: Conversation = {
      id: `conv-${Date.now()}`,
      workspaceId,
      title: title || 'New Conversation',
      modelId,
      messages: [],
      injectedMemories: [],
      status: 'active',
      createdAt: new Date(),
      updatedAt: new Date(),
    };
    
    set(state => ({
      conversations: [...state.conversations, newConversation],
      activeConversationId: newConversation.id,
    }));
    
    return newConversation.id;
  },

  updateConversation: (id: string, updates: Partial<Conversation>) => {
    set(state => ({
      conversations: state.conversations.map(conv =>
        conv.id === id ? { ...conv, ...updates, updatedAt: new Date() } : conv
      ),
    }));
  },

  deleteConversation: (id: string) => {
    set(state => ({
      conversations: state.conversations.filter(conv => conv.id !== id),
      activeConversationId: state.activeConversationId === id ? null : state.activeConversationId,
    }));
  },

  setActiveConversation: (id: string | null) => {
    set({ activeConversationId: id });
  },

  sendMessage: (conversationId: string, content: string, role: 'user' | 'assistant' = 'user') => {
    const newMessage: Message = {
      id: `msg-${Date.now()}`,
      conversationId,
      role,
      content,
      timestamp: new Date(),
      isPinned: false,
    };
    
    set(state => ({
      conversations: state.conversations.map(conv => {
        if (conv.id === conversationId) {
          return {
            ...conv,
            messages: [...conv.messages, newMessage],
            updatedAt: new Date(),
          };
        }
        return conv;
      }),
    }));
    
    // Simulate AI response for user messages
    if (role === 'user') {
      setTimeout(() => {
        const aiMessage: Message = {
          id: `msg-${Date.now()}`,
          conversationId,
          role: 'assistant',
          content: 'This is a simulated AI response. In the full implementation, this would be generated by the selected cognitive model with access to injected memories.',
          timestamp: new Date(),
          isPinned: false,
        };
        
        set(state => ({
          conversations: state.conversations.map(conv => {
            if (conv.id === conversationId) {
              return {
                ...conv,
                messages: [...conv.messages, aiMessage],
                updatedAt: new Date(),
              };
            }
            return conv;
          }),
        }));
      }, 1500);
    }
  },

  pinMessage: (messageId: string) => {
    set(state => ({
      conversations: state.conversations.map(conv => ({
        ...conv,
        messages: conv.messages.map(msg =>
          msg.id === messageId ? { ...msg, isPinned: true } : msg
        ),
      })),
    }));
  },

  unpinMessage: (messageId: string) => {
    set(state => ({
      conversations: state.conversations.map(conv => ({
        ...conv,
        messages: conv.messages.map(msg =>
          msg.id === messageId ? { ...msg, isPinned: false } : msg
        ),
      })),
    }));
  },

  deleteMessage: (messageId: string) => {
    set(state => ({
      conversations: state.conversations.map(conv => ({
        ...conv,
        messages: conv.messages.filter(msg => msg.id !== messageId),
      })),
    }));
  },

  injectMemory: (conversationId: string, memoryId: string) => {
    set(state => ({
      conversations: state.conversations.map(conv => {
        if (conv.id === conversationId && !conv.injectedMemories.includes(memoryId)) {
          return {
            ...conv,
            injectedMemories: [...conv.injectedMemories, memoryId],
            updatedAt: new Date(),
          };
        }
        return conv;
      }),
    }));
  },

  removeInjectedMemory: (conversationId: string, memoryId: string) => {
    set(state => ({
      conversations: state.conversations.map(conv => {
        if (conv.id === conversationId) {
          return {
            ...conv,
            injectedMemories: conv.injectedMemories.filter(id => id !== memoryId),
            updatedAt: new Date(),
          };
        }
        return conv;
      }),
    }));
  },

  setAutoStore: (enabled: boolean) => {
    set({ autoStore: enabled });
  },

  getConversationsByWorkspace: (workspaceId: string) => {
    return get().conversations.filter(conv => conv.workspaceId === workspaceId);
  },

  getConversationById: (id: string) => {
    return get().conversations.find(conv => conv.id === id);
  },

  getActiveConversation: () => {
    const state = get();
    return state.conversations.find(conv => conv.id === state.activeConversationId) || null;
  },

  getMessageById: (id: string) => {
    const conversations = get().conversations;
    for (const conv of conversations) {
      const message = conv.messages.find(msg => msg.id === id);
      if (message) return message;
    }
    return undefined;
  },
}));
